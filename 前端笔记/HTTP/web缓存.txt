web缓存
    存在于服务器和客户端之间。web缓存密切注视着服务器-客户端之间的通信，监控请求，并且把请求输出的内容和（如html页面，图片和文件）另存一份，然后，如果下一个请求是相同的URL，则直接使用保存的副本，而不是再次请求服务器，种类分为：
	
	    1数据库数据缓存---为了提供查询的性能，会将查询后的数据放在内存中及进行缓存，下次查询时，直接从内存缓存直接返回
		2 服务器端缓存
		    代理服务器缓存
			CDN缓存
				没有CDN：浏览器缓存
				使用CDN：浏览器缓存 + CDN缓存
					浏览器本地缓存失效后，浏览器会向CDN边缘节点发起请求，类似浏览器缓存，CDN边缘节点也存在一套缓存机制，此机制因服务商的不同而不同，但一般都会遵循http标准协议，通过http响应头中的cache-cntrol: max-age的字段来设置CDN边缘节点数据缓存时间。
		3 浏览器缓存---根据一套与服务器约定的规则进行工作，在同一个回话过程中检查一次并确定缓存的副本足够新
		4 web应用层缓存
	
	
	HTTP首部信息控制缓存
		1.通用首部字段
			Cache-Control  控制缓存的行为
				Cache-Control: no-cache 是会被缓存的，只不过每次在向客户端提供相应数据时，缓存都要向服务器评估缓存响应的有效性
			Pragma http1.0的遗物，值为no-cache时禁用缓存
		2.请求首部字段
			If-Macth 比较ETag是否一致
			If-none-Macth 比较ETag是否不一致
			If-Modified-Since 比较资源最后更新的时间是否一致
			If-UnModified-Since 比较资源最后更新的时间是否不一致
		3.响应首部字段
			ETag           资源匹配信息
		4.实体首部字段
			Expires http1.0遗留，实体主体过期的时间
			Last-Modified 资源的最后一次修改时间
		
		
	Last-Modified/If-Modified-Since
		Last-Modified/If-Modified-Since要配合Cache-Control使用
		(1) Last-Modified：标示这个响应资源的最后修改时间。web服务器在响应请求时，告诉浏览器资源的最后修改时间。
		(2)If-Modified-Since：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头If-Modified-Since，表示请求时间。web服务器收到请求后发现有头If-Modified-Since则与被请求资源的最后修改时间进行比对。若最后修改时间较新，说明资源又被改动过，则响应整片资源内容（写在响应消息包体内），HTTP200；若最后修改时间较旧，说明资源无新修改，则响应HTTP304 (无需包体，节省浏览)，告知浏览器继续使用所保存的cache。
	Etag/If-None-Match
		Etag/If-None-Match也要配合Cache-Control使用。
		(1)Etag：web服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。
		(2)If-None-Match：当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etage声明，则再次向web服务器请求时带上头If-None-Match（Etag的值）。web服务器收到请求后发现有头If-None-Match则与被请求资源的相应校验串进行比对，决定返回200或304。
	既生Last-Modified何生Etag？
		你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag（实体标识）呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：
		(1)Last-Modified标注的最后修改只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，它将不能准确标注文件的修改时间

		(2)如果某些文件会被定期生成，当有时内容并没有任何变化，但Last-Modified却改变了，导致文件没法使用缓存

		(3)有可能存在服务器没有准确获取文件修改时间，或者与代理服务器时间不一致等情形

		Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符，能够更加准确的控制缓存。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。
	
	
	浏览器缓存为分强缓存和协商缓存，当客户端请求某个资源时，获取缓存的流程如下：
        1先根据这个资源的一个http头部判断它是否命中强缓存，如果命中，则直接从本地获取缓存资源，不会则发送请求到服务器
        2当强缓存没有命中时，客户端会发送请求到服务器，服务器通过另一些request_header验证是否命中协商缓存，称为http再验证，如果命中，服务器将请求返回，但不是返回资源，而是告诉客户端直接从缓存中获取
		
        3共同之处在于如果命中缓存，服务器都不会返回资源，区别是强缓存不会发送请求到服务器，但协商缓存会	