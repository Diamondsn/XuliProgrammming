JS的单线程是指一个浏览器进程中只会给JS分配一个主执行线程，同一时刻内只会有一段代码在执行（你可以使用IE的标签式浏览试试看效果，这时打开的多个页面使用的都是同一个JS执行线程，如果其中一个页面在执行一个运算量较大的function时，其他窗口的JS就会停止工作）。而异步机制是浏览器的两个或以上常驻线程共同完成的，例如异步请求是由两个常驻线程：JS执行线程和事件触发线程共同完成的，JS的执行线程发起异步请求（这时浏览器会开一条新的HTTP请求线程来执行请求，这时JS的任务已完成，继续执行线程队列中剩下的其他任务），然后在未来的某一时刻事件触发线程监视到之前的发起的HTTP请求已完成，它就会把完成事件插入到JS执行队列的尾部等待JS处理。又例如定时触发（setTimeout和setInterval）是由浏览器的定时器线程执行的定时计数，然后在定时时间把定时处理函数的执行请求插入到JS执行队列的尾端（所以用这两个函数的时候，实际的执行时间是大于或等于指定时间的，不保证能准确定时的）。所以，所谓的JS的单线程和异步更多的应该是属于浏览器的行为，他们之间没有冲突，更不是同一种事物，没有什么区别不区别的。

总的来说：单线程和异步确实不能同时成为一个语言的特性，JS选择了成为单线程语言，所以它本省不可能是异步的，但JS的宿主环境(比如浏览器，Node)是多线程的，宿主环境通过某种方式(事件驱动)使得JS具备了异步的属性。JS一直是单线程的，浏览器和node才是实现异步的家伙

浏览器只分配给JS一个主线程，用来执行任务(函数)，但一次只能执行一个任务，这些任务形成一个任务队列排队等候执行，但前端某些任务是非常耗时的，比如网络请求，定时器和事件监听，如果让他们和别的任务一样，都老老实实的排队等待执行的话，执行效率会非常的低，甚至导致页面的假死，所以浏览器为这些耗时的任务开辟了另外的进程，主要包括http请求线程，浏览器定时触发线程，浏览器事件触发线程，这些任务是异步的

JS中实现异步的方法
	js一直是单线程执行的，浏览器为几个明显的耗时任务单独开辟线程解决耗时问题，但是js除了这几个明显的耗时问题外，可能我们自己写的程序里面也会有耗时的函数，这种情况怎么处理呢？我们肯定不能自己开辟单独的线程，但我们可以利用浏览器给我们开放的这几个窗口，浏览器定时器线程和事件触发线程是好利用的，网络请求线程不适合我们使用。
	具体方法：
		ES6以前：
			(1)回调函数
				回调是一个函数被作为一个参数传递到另一个函数里，在父函数执行完之后它再执行
				function f1(callback){
					setTimeout(function(){
						//f1的任务代码
						callback();
					},1000);
				}
				f1(f2);
				但回调并不一定就是异步的，他们自己并没有直接关系
				function A(callback){
					console.log("I am A");
					callback();
				}
				function B(){
					console.log("I am B");
				}
				A(B)
				
			(2)事件监听
				采用事件驱动模式，任务的执行不取决代码的顺序，而取决于某一件事件是否发生，监听函数有on，bind，listen，addEventListen，observe
					f1.addEventListen("done",f2,false)
					代码的意思是当f1发生done就执行f2
			
			(3)发布订阅(观察者模式)---它定义了一种一对多的关系，让观察者同时对监听某一个主题对象，这一主题对象的状态变化就会通知多有的观察者对象，使他们能够自动更新自己
		ES6: 	
			(4)Promise对象
			(5)Generator函数
		ES7：
			(6)async和await

除了广义的同步任务和异步任务，还有对任务更精细的定义
	marco-task(宏任务)： 包括整体代码script setTimeout setInterval
	micro-task(微任务)： Promise porcess.nextTick
	不同类型的任务会进入对应的Event Quenue 
	事件循环的顺序，决定js代码的执行顺序。进入整体代码(宏任务)后，开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到其中一个任务队列执行完毕，再执行所有的微任务