Nodejs采用模块化结构，按照CommonJS规范定义和使用模块。模块与文件是一一对应关系，即加载一个模块实际上就是加载对应的一个模块文件

JS是脚本语言，脚本语言都需要一个解析器才能运行，对于在HTML页面里的JS，浏览器充当了解析器的角色，而对于需要独立运行的JS，Nodejs即是一个解析器，任何一种解析器都是一个运行环境，不但允许JS定义各种数据结构进行各种计算，还允许JS使用运行环境提供的内置对象和方法做一些事情，例如运行在浏览器中的JS的用途是操作DOM，浏览器就提供了document之类的内置对象。而运行在NodeJS中的JS的用途是操作磁盘文件或搭建Http服务器，所以Nodejs就提供了fs，http等内置对象

所有能触发事件的对象都是EventEmitter类的实例，这些对象开放了一个eventEmitter.on()函数，允许将一个或多个函数绑定到会被对象触发的命名事件上。事件名称通常是驼峰式的字符串，但也可以使用任何有效的Javascript属性名，当EventEmitter对象触发了一个事件时，所有绑定在该事件上的函数都被同步地调用EventEmitter.on()方法用于注册监听器，EventEmitter.emit()方法用于触发事件，EventEmitter会按照监听器注册的顺序同步地调用所有监听器。所以需要确保事件的正确排序且避免竞争条件或逻辑错误。监听器函数可以使用setImmediate()或process.nextTick()方法切换到异步操作模式	

CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则非同步加载模块，允许指定回调函数。由于Node.js主要用于服务器编程，模块文件一般都已经存在于本地硬盘，所以加载起来比较快，不用考虑非同步加载的方式，但是如果是浏览器环境，要从服务器端加载模块，这时就必须采用非同步模式，因此浏览器一般采用AMD

require加载某个模块时，Node会缓存该模块，如果发生模块的循环加载，即A加载B，B又加载A，则B将加载A的不完整版本。CommonJS模块的机制是，输入的是被输出的值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值


COmmonjs 同步加载模块，不能非阻塞的加载多个模块
AMD 异步加载，提前执行，依赖前置
CMD 异步加载，延迟执行，依赖就近